观察者模式：

观察模式中，
1. 观察者需要包含所有的被观察者，被观察者需要用一个结构存储，这里使用list结构。然后通过ADD方法向list中添加新的被观察者。
2. 观察者需要有一个通知被观察者的方法。这里用nofify方法通知。里面的实现是调用被观察者的notify方法。
    其中，被观察者的notify方法用来告诉被观察者的操作
3. 观察者还要有一个取消被观察者的方法。这样可以更加灵活的处置问题。
4. 被观察者需要获取观察者的状态，以了解到底发现了什么事情。

为了保证代码之间的结构。观察者和被观察者都可以设置一个抽象的观察者，抽象的悲观者接口，然后分别实现。
这就体现了面向对象编程的依赖倒转原则（面向抽象，接口编程）和开闭原则。

观察者模式又称为发布-订阅模式
观察者模式定义了一种一对多的依赖关系，让多个观察者对象（也就是上面写的被观察者）同时监听一个主题对象
（上面提到的观察者）。这个主题对象在状态发生变化时会通知所有观察者，是它们可以自动更新自己。

观察者模式所做的工作其实就是解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。

现实工作中，被观察者可能是风马牛不相及的类。他们只需要实现notify方法即可（对于不同的业务，notify方法内部实现不一致）
由于这里对抽象被观察者类实现的都是同名notify方法仍然有一定的耦合，不容易扩展。可以通过委托机制实现更加大范围的扩展。

事件委托机制：
C#中通过委托机制，将不同类对于同一事件不同响应方法挂在同一个方法名中。Java中目前没有一个好的委托模式的封装。
委托是一种引用方法的类型，可以看作是对函数的抽象，是函数的类，委托的实例将代表一个具体的函数。
委托对象所搭载的所有方法必须具有相同的原型和形式。也就是具有相同的参数列表和返回值类型。

这里使用抽象主题和抽象观察者对同事通知相关事件构建一个观察者模式